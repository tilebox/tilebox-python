# Generated by the gRPC Python protocol compiler plugin. DO NOT EDIT!
"""Client and server classes corresponding to protobuf-defined services."""
import grpc

from tilebox.workflows.workflowsv1 import core_pb2 as workflows_dot_v1_dot_core__pb2
from tilebox.workflows.workflowsv1 import task_pb2 as workflows_dot_v1_dot_task__pb2


class TaskServiceStub(object):
    """A service for task runners to communicate with the workflows service.
    """

    def __init__(self, channel):
        """Constructor.

        Args:
            channel: A grpc.Channel.
        """
        self.NextTask = channel.unary_unary(
                '/workflows.v1.TaskService/NextTask',
                request_serializer=workflows_dot_v1_dot_task__pb2.NextTaskRequest.SerializeToString,
                response_deserializer=workflows_dot_v1_dot_task__pb2.NextTaskResponse.FromString,
                _registered_method=True)
        self.TaskFailed = channel.unary_unary(
                '/workflows.v1.TaskService/TaskFailed',
                request_serializer=workflows_dot_v1_dot_task__pb2.TaskFailedRequest.SerializeToString,
                response_deserializer=workflows_dot_v1_dot_task__pb2.TaskStateResponse.FromString,
                _registered_method=True)
        self.ExtendTaskLease = channel.unary_unary(
                '/workflows.v1.TaskService/ExtendTaskLease',
                request_serializer=workflows_dot_v1_dot_task__pb2.TaskLeaseRequest.SerializeToString,
                response_deserializer=workflows_dot_v1_dot_core__pb2.TaskLease.FromString,
                _registered_method=True)


class TaskServiceServicer(object):
    """A service for task runners to communicate with the workflows service.
    """

    def NextTask(self, request, context):
        """NextTask marks a task as computed and asks for the next task to run.
        If no task marked as computed is sent, it is assumed that the task runner just started up or was idling so
        the task server will send a task to run using a work-stealing algorithm.
        If a task marked as computed is sent, the task server will send a next task to run using a depth first execution
        algorithm, and only fall back to work-stealing if otherwise no tasks are available.
        If the next_task_to_run field of the request is not set, a next task will never be returned, but a task
        can still be marked as computed this way.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def TaskFailed(self, request, context):
        """TaskFailed tells the task server that we have failed to compute a task.
        The task server will then mark the task as queued or failed, depending on the retry policy,
        and possibly cancel the job.
        If a task runner wants to continue executing tasks, it should afterwards fetch a new one using GetTaskToRun.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')

    def ExtendTaskLease(self, request, context):
        """ExtendTaskLease is called by the task runner to extend the lease on a task.
        On success, the response will contain the new lease expiration time.
        If the task does not need to be extended, the response will be empty.
        """
        context.set_code(grpc.StatusCode.UNIMPLEMENTED)
        context.set_details('Method not implemented!')
        raise NotImplementedError('Method not implemented!')


def add_TaskServiceServicer_to_server(servicer, server):
    rpc_method_handlers = {
            'NextTask': grpc.unary_unary_rpc_method_handler(
                    servicer.NextTask,
                    request_deserializer=workflows_dot_v1_dot_task__pb2.NextTaskRequest.FromString,
                    response_serializer=workflows_dot_v1_dot_task__pb2.NextTaskResponse.SerializeToString,
            ),
            'TaskFailed': grpc.unary_unary_rpc_method_handler(
                    servicer.TaskFailed,
                    request_deserializer=workflows_dot_v1_dot_task__pb2.TaskFailedRequest.FromString,
                    response_serializer=workflows_dot_v1_dot_task__pb2.TaskStateResponse.SerializeToString,
            ),
            'ExtendTaskLease': grpc.unary_unary_rpc_method_handler(
                    servicer.ExtendTaskLease,
                    request_deserializer=workflows_dot_v1_dot_task__pb2.TaskLeaseRequest.FromString,
                    response_serializer=workflows_dot_v1_dot_core__pb2.TaskLease.SerializeToString,
            ),
    }
    generic_handler = grpc.method_handlers_generic_handler(
            'workflows.v1.TaskService', rpc_method_handlers)
    server.add_generic_rpc_handlers((generic_handler,))
    server.add_registered_method_handlers('workflows.v1.TaskService', rpc_method_handlers)


 # This class is part of an EXPERIMENTAL API.
class TaskService(object):
    """A service for task runners to communicate with the workflows service.
    """

    @staticmethod
    def NextTask(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/workflows.v1.TaskService/NextTask',
            workflows_dot_v1_dot_task__pb2.NextTaskRequest.SerializeToString,
            workflows_dot_v1_dot_task__pb2.NextTaskResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def TaskFailed(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/workflows.v1.TaskService/TaskFailed',
            workflows_dot_v1_dot_task__pb2.TaskFailedRequest.SerializeToString,
            workflows_dot_v1_dot_task__pb2.TaskStateResponse.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)

    @staticmethod
    def ExtendTaskLease(request,
            target,
            options=(),
            channel_credentials=None,
            call_credentials=None,
            insecure=False,
            compression=None,
            wait_for_ready=None,
            timeout=None,
            metadata=None):
        return grpc.experimental.unary_unary(
            request,
            target,
            '/workflows.v1.TaskService/ExtendTaskLease',
            workflows_dot_v1_dot_task__pb2.TaskLeaseRequest.SerializeToString,
            workflows_dot_v1_dot_core__pb2.TaskLease.FromString,
            options,
            channel_credentials,
            insecure,
            call_credentials,
            compression,
            wait_for_ready,
            timeout,
            metadata,
            _registered_method=True)
